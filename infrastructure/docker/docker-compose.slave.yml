# =============================================================================
# Mandari 2.0 - Docker Compose (Slave/Replica)
# =============================================================================
# This configuration runs on the slave server with:
# - NO local PostgreSQL - connects to Master's PostgreSQL directly
# - NO local Redis - connects to Master's Redis directly
# - Local Meilisearch (search index is local for performance)
# - NO Ingestor service (only runs on master)
#
# This ensures data consistency across servers and simplifies deployment.
# Master IP: 10.0.0.3 (Hetzner private network)
# =============================================================================

name: mandari

services:
  # ===========================================================================
  # Reverse Proxy (Custom Caddy with Hetzner DNS plugin for DNS-01 challenge)
  # ===========================================================================
  caddy:
    build:
      context: ./caddy
      dockerfile: Dockerfile
    image: mandari-caddy:latest
    container_name: mandari-caddy
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    environment:
      HETZNER_DNS_API_TOKEN: ${HETZNER_DNS_API_TOKEN}
      DOMAIN: ${DOMAIN:-mandari.de}
    volumes:
      - ./Caddyfile:/etc/caddy/Caddyfile:ro
      - caddy_data:/data
      - caddy_config:/config
    networks:
      - mandari-network
    depends_on:
      api:
        condition: service_started
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:80/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  # ===========================================================================
  # NO LOCAL DATABASE ON SLAVE
  # ===========================================================================
  # The slave connects directly to the Master's PostgreSQL via private network
  # This ensures data consistency and simplifies deployment.
  # Master IP: ${MASTER_PRIVATE_IP:-10.0.0.3}

  # ===========================================================================
  # NO LOCAL REDIS ON SLAVE - connects to Master's Redis directly
  # ===========================================================================
  # The slave connects directly to the Master's Redis via private network
  # This ensures session data and caches are shared across all servers.

  # ===========================================================================
  # Search Engine
  # ===========================================================================
  meilisearch:
    image: getmeili/meilisearch:v1.6
    container_name: mandari-meilisearch
    restart: unless-stopped
    environment:
      MEILI_ENV: production
      MEILI_MASTER_KEY: ${MEILISEARCH_KEY}
      MEILI_NO_ANALYTICS: "true"
      MEILI_HTTP_PAYLOAD_SIZE_LIMIT: 104857600
    volumes:
      - ${DATA_DIR:-/mnt/data}/meilisearch:/meili_data
    networks:
      - mandari-network
    healthcheck:
      test: ["CMD-SHELL", "curl -sf http://localhost:7700/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 30s

  # ===========================================================================
  # API Backend
  # ===========================================================================
  api:
    image: ghcr.io/mandarioss/mandari:${IMAGE_TAG:-latest}
    container_name: mandari-api
    restart: unless-stopped
    environment:
      # Database - connects directly to Master's PostgreSQL via private network
      DATABASE_URL: postgresql+asyncpg://${POSTGRES_USER:-mandari}:${POSTGRES_PASSWORD}@${MASTER_PRIVATE_IP:-10.0.0.3}:5432/${POSTGRES_DB:-mandari}
      # Cache - connects directly to Master's Redis via private network
      REDIS_URL: redis://${MASTER_PRIVATE_IP:-10.0.0.3}:6379
      # Search - local Meilisearch (search index can differ per server)
      MEILISEARCH_URL: http://meilisearch:7700
      MEILISEARCH_KEY: ${MEILISEARCH_KEY}
      # App
      SECRET_KEY: ${SECRET_KEY}
      DEBUG: "false"
      ENVIRONMENT: production
      SITE_URL: ${SITE_URL}
      ALLOWED_HOSTS: ${ALLOWED_HOSTS}
      CSRF_TRUSTED_ORIGINS: ${CSRF_TRUSTED_ORIGINS}
      # Encryption
      ENCRYPTION_MASTER_KEY: ${ENCRYPTION_MASTER_KEY}
      # Replica mode flag (still useful for read-preference logic)
      IS_REPLICA: "true"
    networks:
      - mandari-network
    extra_hosts:
      # Ensure the container can resolve master's private IP
      - "master-db:${MASTER_PRIVATE_IP:-10.0.0.3}"
    depends_on:
      meilisearch:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "python -c \"import urllib.request; urllib.request.urlopen('http://localhost:8000/health')\" || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 60s
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M

  # ===========================================================================
  # NO INGESTOR ON SLAVE!
  # ===========================================================================
  # The ingestor service only runs on the master to avoid
  # duplicate ingestion and write conflicts.

  # ===========================================================================
  # Frontend Services (Django serves everything via HTMX)
  # ===========================================================================
  # NOTE: Mandari uses Django Templates + HTMX, not separate frontend apps.
  # All routes are served by the 'api' service (Django).

# =============================================================================
# Volumes
# =============================================================================
volumes:
  caddy_data:
  caddy_config:

# =============================================================================
# Networks
# =============================================================================
networks:
  mandari-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16

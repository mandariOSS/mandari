---
# =============================================================================
# Mandari 2.0 - Application Deployment Playbook
# =============================================================================
# IMPORTANT: Master is deployed FIRST, then Slave
# This ensures migrations run before slave connects to master DB
#
# This playbook is SELF-CONTAINED and includes:
# - Docker installation (if not present)
# - User creation (if not present)
# - Directory setup
# - Container deployment
# =============================================================================

# =============================================================================
# PHASE 0: Bootstrap All Servers (Docker, Users, Directories)
# =============================================================================
- name: Bootstrap Servers
  hosts: all_servers
  become: yes
  gather_facts: yes

  tasks:
    # =========================================================================
    # Install Docker (if not present)
    # =========================================================================
    - name: Check if Docker is installed
      command: docker --version
      register: docker_check
      ignore_errors: yes
      changed_when: false

    - name: Install Docker dependencies
      apt:
        name:
          - apt-transport-https
          - ca-certificates
          - curl
          - gnupg
          - lsb-release
          - python3-pip
          - python3-docker
        state: present
        update_cache: yes
      when: docker_check.rc != 0

    - name: Add Docker GPG key
      apt_key:
        url: https://download.docker.com/linux/ubuntu/gpg
        state: present
      when: docker_check.rc != 0

    - name: Add Docker repository
      apt_repository:
        repo: "deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
        state: present
      when: docker_check.rc != 0

    - name: Install Docker
      apt:
        name:
          - docker-ce
          - docker-ce-cli
          - containerd.io
          - docker-buildx-plugin
          - docker-compose-plugin
        state: present
        update_cache: yes
      when: docker_check.rc != 0

    - name: Start and enable Docker
      systemd:
        name: docker
        state: started
        enabled: yes

    # =========================================================================
    # Create deploy user (if not present)
    # =========================================================================
    - name: Check if deploy user exists
      getent:
        database: passwd
        key: "{{ app_user }}"
      register: user_check
      ignore_errors: yes

    - name: Create deploy user
      user:
        name: "{{ app_user }}"
        groups: docker
        shell: /bin/bash
        create_home: yes
        state: present
      when: user_check.failed | default(false)

    - name: Add deploy user to docker group (ensure)
      user:
        name: "{{ app_user }}"
        groups: docker
        append: yes

    # =========================================================================
    # Create directories (as root, then chown)
    # =========================================================================
    - name: Create application directories
      file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
      loop:
        - "{{ app_dir }}"
        - "{{ app_dir }}/backups"
        - "{{ app_dir }}/scripts"
        - "{{ data_dir }}"
        - "{{ data_dir }}/postgres"
        - "{{ data_dir }}/redis"
        - "{{ data_dir }}/meilisearch"

    - name: Create ingestor data directory (master only)
      file:
        path: "{{ data_dir }}/ingestor"
        state: directory
        mode: '0755'
      when: run_ingestor | default(false)

    - name: Set directory ownership
      file:
        path: "{{ item }}"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        recurse: no
      loop:
        - "{{ app_dir }}"
        - "{{ app_dir }}/backups"
        - "{{ app_dir }}/scripts"
      ignore_errors: yes

# =============================================================================
# PHASE 1: Deploy Master (Primary)
# =============================================================================
- name: Deploy Master Server
  hosts: master
  become: yes
  gather_facts: yes
  serial: 1

  vars:
    compose_file: "docker-compose.master.yml"
    deploy_timestamp: "{{ ansible_facts['date_time']['epoch'] }}"

  tasks:
    # =========================================================================
    # Cleanup & Prepare (preserve volumes for SSL cert cache)
    # =========================================================================
    - name: Stop all existing containers (preserve volumes)
      shell: |
        cd {{ app_dir }} && docker compose down --remove-orphans 2>/dev/null || true
        docker ps -a --filter "name=mandari-" -q | xargs -r docker rm -f 2>/dev/null || true
      ignore_errors: yes

    - name: Sync Docker Compose files
      copy:
        src: "{{ playbook_dir }}/../../docker/{{ item }}"
        dest: "{{ app_dir }}/{{ item }}"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: '0644'
      loop:
        - docker-compose.master.yml
        - docker-compose.slave.yml
        - Caddyfile
        - pg_hba.conf

    - name: Sync Caddy Dockerfile directory
      copy:
        src: "{{ playbook_dir }}/../../docker/caddy/"
        dest: "{{ app_dir }}/caddy/"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: '0644'

    - name: Sync environment file
      copy:
        src: "{{ playbook_dir }}/../../docker/.env"
        dest: "{{ app_dir }}/.env"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: '0600'

    - name: Create Docker Compose symlink
      file:
        src: "{{ app_dir }}/{{ compose_file }}"
        dest: "{{ app_dir }}/docker-compose.yml"
        state: link
        force: yes

    # =========================================================================
    # PostgreSQL Reinitialization (if requested)
    # =========================================================================
    - name: Check if PostgreSQL needs reinitialization
      stat:
        path: "{{ data_dir }}/postgres/PG_VERSION"
      register: pg_data_exists

    - name: Clear PostgreSQL data for reinitialization
      file:
        path: "{{ data_dir }}/postgres"
        state: absent
      when: force_postgres_reinit | default(false) | bool

    - name: Recreate PostgreSQL data directory
      file:
        path: "{{ data_dir }}/postgres"
        state: directory
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: '0755'
      when: force_postgres_reinit | default(false) | bool

    # =========================================================================
    # Docker Registry & Pull
    # =========================================================================
    - name: Login to GitHub Container Registry
      community.docker.docker_login:
        registry: ghcr.io
        username: "{{ ghcr_username }}"
        password: "{{ ghcr_token }}"
      when: ghcr_token is defined and ghcr_token | length > 0

    - name: Pull latest images (excluding locally built images)
      shell: cd {{ app_dir }} && docker compose -f {{ compose_file }} pull --ignore-buildable
      ignore_errors: yes

    - name: Build custom Caddy image with Hetzner DNS plugin
      shell: cd {{ app_dir }} && docker compose -f {{ compose_file }} build caddy
      register: caddy_build

    # =========================================================================
    # Start Infrastructure Containers (Database, Cache, Search)
    # =========================================================================
    - name: Start infrastructure containers only (postgres, redis, meilisearch)
      shell: |
        cd {{ app_dir }}
        docker compose -f {{ compose_file }} up -d postgres redis meilisearch
      register: infra_start

    - name: Wait for PostgreSQL to be healthy
      shell: |
        for i in {1..60}; do
          docker exec mandari-postgres pg_isready -U ${POSTGRES_USER:-mandari} && exit 0
          sleep 2
        done
        exit 1
      environment:
        POSTGRES_USER: "{{ lookup('env', 'POSTGRES_USER') | default('mandari', true) }}"
      register: pg_ready
      retries: 3
      delay: 5
      until: pg_ready.rc == 0

    - name: Wait for PostgreSQL to fully initialize
      pause:
        seconds: 5

    # =========================================================================
    # Run Migrations BEFORE starting API (prevents race condition)
    # =========================================================================
    - name: Get Docker network name
      shell: docker network ls --filter name=mandari --format '{{ '{{' }}.Name{{ '}}' }}' | grep -E 'mandari.*network' | head -1
      register: docker_network
      changed_when: false

    - name: Run database migrations using temporary container
      shell: |
        cd {{ app_dir }}
        # Load environment variables from .env file (POSIX compatible)
        export $(grep -v '^#' .env | xargs)
        # Get the network name
        NETWORK_NAME="{{ docker_network.stdout | default('mandari_mandari-network') }}"
        # Run migrations using the API image
        docker run --rm \
          --network "$NETWORK_NAME" \
          --env-file .env \
          -e DATABASE_URL="postgresql://${POSTGRES_USER:-mandari}:${POSTGRES_PASSWORD}@mandari-postgres:5432/${POSTGRES_DB:-mandari}" \
          -e ALLOWED_HOSTS="localhost" \
          ghcr.io/mandarioss/mandari:${IMAGE_TAG:-latest} \
          python manage.py migrate --noinput
      args:
        executable: /bin/bash
      register: migration_result
      retries: 3
      delay: 10
      until: migration_result.rc == 0

    - name: Display migration result
      debug:
        msg: "{{ migration_result.stdout_lines | default(['Migrations completed']) }}"

    - name: Setup Django roles and permissions
      shell: |
        cd {{ app_dir }}
        export $(grep -v '^#' .env | xargs)
        NETWORK_NAME="{{ docker_network.stdout | default('mandari_mandari-network') }}"
        docker run --rm \
          --network "$NETWORK_NAME" \
          --env-file .env \
          -e DATABASE_URL="postgresql://${POSTGRES_USER:-mandari}:${POSTGRES_PASSWORD}@mandari-postgres:5432/${POSTGRES_DB:-mandari}" \
          -e ALLOWED_HOSTS="localhost" \
          ghcr.io/mandarioss/mandari:${IMAGE_TAG:-latest} \
          python manage.py setup_roles
      args:
        executable: /bin/bash
      ignore_errors: yes

    # =========================================================================
    # Now Start All Containers (API, Ingestor, Caddy)
    # =========================================================================
    - name: Start all containers
      community.docker.docker_compose_v2:
        project_src: "{{ app_dir }}"
        files:
          - "{{ compose_file }}"
        state: present
        recreate: always
        remove_orphans: true
      register: compose_result

    # =========================================================================
    # Health Check
    # =========================================================================
    - name: Wait for API to be healthy
      shell: docker inspect --format='{{ '{{' }}.State.Health.Status{{ '}}' }}' mandari-api
      register: api_health
      retries: 30
      delay: 5
      until: api_health.stdout == 'healthy'

    # =========================================================================
    # Wait for SSL Certificate and Export for Slave
    # =========================================================================
    - name: Wait for Caddy to obtain SSL certificate
      shell: >-
        for i in $(seq 1 60); do
        if docker exec mandari-caddy ls /data/caddy/certificates/acme-v02.api.letsencrypt.org-directory/mandari.de/mandari.de.crt 2>/dev/null; then
        echo "Certificate found"; exit 0; fi;
        echo "Waiting for certificate... attempt $i"; sleep 10; done;
        echo "Certificate not found after 10 minutes"; exit 1
      args:
        executable: /bin/bash
      register: cert_wait
      retries: 2
      delay: 30
      until: cert_wait.rc == 0

    - name: Create temporary directory for certificate export
      file:
        path: /tmp/caddy-certs
        state: directory
        mode: '0700'

    - name: Export Caddy certificate data from Docker volume
      shell: >-
        docker run --rm
        -v mandari_caddy_data:/data:ro
        -v /tmp/caddy-certs:/backup
        alpine:latest
        sh -c "cp -r /data/caddy /backup/ 2>/dev/null || true"
      register: cert_export

    - name: Verify certificate export
      stat:
        path: /tmp/caddy-certs/caddy
      register: cert_exported

    - name: Fail if certificate export failed
      fail:
        msg: "Failed to export Caddy certificates from Master"
      when: not cert_exported.stat.exists

    - name: Master deployment complete
      debug:
        msg: "✅ Master deployment complete. Migrations applied. SSL certificate exported."

# =============================================================================
# PHASE 1.5: Transfer SSL Certificates from Master to Slave
# =============================================================================
- name: Transfer SSL Certificates
  hosts: master
  become: yes
  gather_facts: no

  tasks:
    - name: Archive certificate data on Master
      archive:
        path: /tmp/caddy-certs/caddy
        dest: /tmp/caddy-certs.tar.gz
        format: gz

    - name: Fetch certificate archive from Master to Ansible controller
      fetch:
        src: /tmp/caddy-certs.tar.gz
        dest: /tmp/caddy-certs-transfer/
        flat: yes

    - name: Clean up temporary files on Master
      file:
        path: "{{ item }}"
        state: absent
      loop:
        - /tmp/caddy-certs
        - /tmp/caddy-certs.tar.gz

- name: Copy SSL Certificates to Slave
  hosts: slave
  become: yes
  gather_facts: no

  tasks:
    - name: Create certificate directory on Slave
      file:
        path: /tmp/caddy-certs
        state: directory
        mode: '0700'

    - name: Copy certificate archive to Slave
      copy:
        src: /tmp/caddy-certs-transfer/caddy-certs.tar.gz
        dest: /tmp/caddy-certs.tar.gz
        mode: '0600'

    - name: Extract certificate archive on Slave
      unarchive:
        src: /tmp/caddy-certs.tar.gz
        dest: /tmp/caddy-certs/
        remote_src: yes

    - name: Verify certificate extracted on Slave
      stat:
        path: /tmp/caddy-certs/caddy
      register: slave_cert_check

    - name: Certificates transferred
      debug:
        msg: "✅ SSL certificates transferred to Slave"
      when: slave_cert_check.stat.exists

    - name: Clean up archive on Slave
      file:
        path: /tmp/caddy-certs.tar.gz
        state: absent

# =============================================================================
# PHASE 2: Deploy Slave (Replica) - AFTER Master is ready
# =============================================================================
- name: Deploy Slave Server
  hosts: slave
  become: yes
  gather_facts: yes
  serial: 1

  vars:
    compose_file: "docker-compose.slave.yml"
    deploy_timestamp: "{{ ansible_facts['date_time']['epoch'] }}"

  tasks:
    # =========================================================================
    # Cleanup & Prepare (WITHOUT removing volumes - we need caddy_data!)
    # =========================================================================
    - name: Stop all existing containers (preserve volumes for SSL cert)
      shell: |
        cd {{ app_dir }} && docker compose down --remove-orphans 2>/dev/null || true
        docker ps -a --filter "name=mandari-" -q | xargs -r docker rm -f 2>/dev/null || true
      ignore_errors: yes

    - name: Sync Docker Compose files
      copy:
        src: "{{ playbook_dir }}/../../docker/{{ item }}"
        dest: "{{ app_dir }}/{{ item }}"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: '0644'
      loop:
        - docker-compose.master.yml
        - docker-compose.slave.yml
        - Caddyfile
        - pg_hba.conf

    - name: Sync Caddy Dockerfile directory
      copy:
        src: "{{ playbook_dir }}/../../docker/caddy/"
        dest: "{{ app_dir }}/caddy/"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: '0644'

    - name: Sync environment file
      copy:
        src: "{{ playbook_dir }}/../../docker/.env"
        dest: "{{ app_dir }}/.env"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: '0600'

    - name: Create Docker Compose symlink
      file:
        src: "{{ app_dir }}/{{ compose_file }}"
        dest: "{{ app_dir }}/docker-compose.yml"
        state: link
        force: yes

    # =========================================================================
    # PostgreSQL Reinitialization (if requested)
    # =========================================================================
    - name: Clear PostgreSQL data for reinitialization
      file:
        path: "{{ data_dir }}/postgres"
        state: absent
      when: force_postgres_reinit | default(false) | bool

    - name: Recreate PostgreSQL data directory
      file:
        path: "{{ data_dir }}/postgres"
        state: directory
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: '0755'
      when: force_postgres_reinit | default(false) | bool

    # =========================================================================
    # Docker Registry & Pull
    # =========================================================================
    - name: Login to GitHub Container Registry
      community.docker.docker_login:
        registry: ghcr.io
        username: "{{ ghcr_username }}"
        password: "{{ ghcr_token }}"
      when: ghcr_token is defined and ghcr_token | length > 0

    - name: Pull latest images (excluding locally built images)
      shell: cd {{ app_dir }} && docker compose -f {{ compose_file }} pull --ignore-buildable
      ignore_errors: yes

    - name: Build custom Caddy image with Hetzner DNS plugin
      shell: cd {{ app_dir }} && docker compose -f {{ compose_file }} build caddy
      register: caddy_build

    # =========================================================================
    # Import SSL Certificates from Master (only if transferred)
    # =========================================================================
    - name: Check if certificate data exists
      stat:
        path: /tmp/caddy-certs/caddy
      register: slave_certs

    - name: Create Caddy data volume if not exists
      shell: docker volume create mandari_caddy_data
      ignore_errors: yes
      when: slave_certs.stat.exists

    - name: Import SSL certificates into Caddy volume
      shell: >-
        docker run --rm
        -v mandari_caddy_data:/data
        -v /tmp/caddy-certs:/backup:ro
        alpine:latest
        sh -c "mkdir -p /data && cp -r /backup/caddy /data/ 2>/dev/null || true"
      when: slave_certs.stat.exists
      register: cert_import

    - name: Verify certificate import
      shell: >-
        docker run --rm
        -v mandari_caddy_data:/data:ro
        alpine:latest
        ls -la /data/caddy/certificates/acme-v02.api.letsencrypt.org-directory/mandari.de/ 2>/dev/null || echo "No certificates yet"
      register: cert_verify
      when: slave_certs.stat.exists

    - name: Display certificate import status
      debug:
        msg: "Certificate import result: {{ cert_verify.stdout_lines | default(['No output']) }}"
      when: slave_certs.stat.exists

    - name: Clean up temporary certificate directory on Slave
      file:
        path: /tmp/caddy-certs
        state: absent

    # =========================================================================
    # Start Containers
    # =========================================================================
    - name: Start all containers
      community.docker.docker_compose_v2:
        project_src: "{{ app_dir }}"
        files:
          - "{{ compose_file }}"
        state: present
        recreate: always
        remove_orphans: true

    # =========================================================================
    # Health Check
    # =========================================================================
    - name: Wait for API to be healthy
      shell: docker inspect --format='{{ '{{' }}.State.Health.Status{{ '}}' }}' mandari-api
      register: api_health
      retries: 30
      delay: 5
      until: api_health.stdout == 'healthy'
      ignore_errors: yes

    - name: Slave deployment complete
      debug:
        msg: "✅ Slave deployment complete."

# =============================================================================
# PHASE 3: Final Verification
# =============================================================================
- name: Verify Deployment
  hosts: all_servers
  become: yes
  gather_facts: no

  tasks:
    - name: Check running containers
      shell: docker ps --format "table {{'{{'}}.Names{{'}}'}}\\t{{'{{'}}.Status{{'}}'}}\\t{{'{{'}}.Ports{{'}}'}}"
      register: docker_ps

    - name: Display running containers
      debug:
        msg: "{{ docker_ps.stdout_lines }}"

    - name: Final health check
      uri:
        url: "http://localhost/health"
        method: GET
        status_code: 200
      register: health_check
      retries: 5
      delay: 5
      until: health_check.status == 200
      ignore_errors: yes

    - name: Deployment summary
      debug:
        msg: |
          ==========================================
          Deployment Complete!
          ==========================================
          Server: {{ inventory_hostname }}
          Role: {{ postgres_role }}
          Health: {{ 'OK' if health_check.status == 200 else 'FAILED' }}
          ==========================================

# =============================================================================
# PHASE 4: Cleanup on Ansible Controller
# =============================================================================
- name: Cleanup Ansible Controller
  hosts: localhost
  connection: local
  gather_facts: no

  tasks:
    - name: Remove temporary certificate transfer directory
      file:
        path: /tmp/caddy-certs-transfer
        state: absent
      ignore_errors: yes

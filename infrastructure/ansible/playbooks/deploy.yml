---
# =============================================================================
# Mandari 2.0 - Application Deployment Playbook
# =============================================================================
# IMPORTANT: Master is deployed FIRST, then Slave
# This ensures migrations run before slave connects to master DB
#
# This playbook is SELF-CONTAINED and includes:
# - Docker installation (if not present)
# - User creation (if not present)
# - Directory setup
# - Container deployment
# =============================================================================

# =============================================================================
# PHASE 0: Bootstrap All Servers (Docker, Users, Directories)
# =============================================================================
- name: Bootstrap Servers
  hosts: all_servers
  become: yes
  gather_facts: yes

  tasks:
    # =========================================================================
    # Install Docker (if not present)
    # =========================================================================
    - name: Check if Docker is installed
      command: docker --version
      register: docker_check
      ignore_errors: yes
      changed_when: false

    - name: Install Docker dependencies
      apt:
        name:
          - apt-transport-https
          - ca-certificates
          - curl
          - gnupg
          - lsb-release
          - python3-pip
          - python3-docker
        state: present
        update_cache: yes
      when: docker_check.rc != 0

    - name: Add Docker GPG key
      apt_key:
        url: https://download.docker.com/linux/ubuntu/gpg
        state: present
      when: docker_check.rc != 0

    - name: Add Docker repository
      apt_repository:
        repo: "deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
        state: present
      when: docker_check.rc != 0

    - name: Install Docker
      apt:
        name:
          - docker-ce
          - docker-ce-cli
          - containerd.io
          - docker-buildx-plugin
          - docker-compose-plugin
        state: present
        update_cache: yes
      when: docker_check.rc != 0

    - name: Start and enable Docker
      systemd:
        name: docker
        state: started
        enabled: yes

    # =========================================================================
    # Create deploy user (if not present)
    # =========================================================================
    - name: Check if deploy user exists
      getent:
        database: passwd
        key: "{{ app_user }}"
      register: user_check
      ignore_errors: yes

    - name: Create deploy user
      user:
        name: "{{ app_user }}"
        groups: docker
        shell: /bin/bash
        create_home: yes
        state: present
      when: user_check.failed | default(false)

    - name: Add deploy user to docker group (ensure)
      user:
        name: "{{ app_user }}"
        groups: docker
        append: yes

    # =========================================================================
    # Create directories (as root, then chown)
    # =========================================================================
    - name: Create application directories (all servers)
      file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
      loop:
        - "{{ app_dir }}"
        - "{{ app_dir }}/backups"
        - "{{ app_dir }}/scripts"
        - "{{ data_dir }}"
        - "{{ data_dir }}/postgres"
        - "{{ data_dir }}/redis"
        - "{{ data_dir }}/meilisearch"

    - name: Create ingestor data directory (master only)
      file:
        path: "{{ data_dir }}/ingestor"
        state: directory
        mode: '0755'
      when: run_ingestor | default(false)

    - name: Set directory ownership
      file:
        path: "{{ item }}"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        recurse: no
      loop:
        - "{{ app_dir }}"
        - "{{ app_dir }}/backups"
        - "{{ app_dir }}/scripts"
      ignore_errors: yes

# =============================================================================
# PHASE 1: Deploy Master (Primary)
# =============================================================================
- name: Deploy Master Server
  hosts: master
  become: yes
  gather_facts: yes
  serial: 1

  vars:
    compose_file: "docker-compose.master.yml"
    deploy_timestamp: "{{ ansible_facts['date_time']['epoch'] }}"

  tasks:
    # =========================================================================
    # Cleanup & Prepare (preserve volumes for SSL cert cache)
    # =========================================================================
    - name: Stop all existing containers (preserve volumes)
      shell: |
        cd {{ app_dir }} && docker compose down --remove-orphans 2>/dev/null || true
        docker ps -a --filter "name=mandari-" -q | xargs -r docker rm -f 2>/dev/null || true
      ignore_errors: yes

    - name: Sync Docker Compose files
      copy:
        src: "{{ playbook_dir }}/../../docker/{{ item }}"
        dest: "{{ app_dir }}/{{ item }}"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: '0644'
      loop:
        - docker-compose.master.yml
        - docker-compose.slave.yml
        - Caddyfile
        - pg_hba.conf

    - name: Sync Caddy Dockerfile directory
      copy:
        src: "{{ playbook_dir }}/../../docker/caddy/"
        dest: "{{ app_dir }}/caddy/"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: '0644'

    - name: Sync environment file
      copy:
        src: "{{ playbook_dir }}/../../docker/.env"
        dest: "{{ app_dir }}/.env"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: '0600'

    - name: Create Docker Compose symlink
      file:
        src: "{{ app_dir }}/{{ compose_file }}"
        dest: "{{ app_dir }}/docker-compose.yml"
        state: link
        force: yes

    # =========================================================================
    # PostgreSQL Reinitialization (if requested)
    # =========================================================================
    - name: Check if PostgreSQL needs reinitialization
      stat:
        path: "{{ data_dir }}/postgres/PG_VERSION"
      register: pg_data_exists

    - name: Clear PostgreSQL data for reinitialization
      file:
        path: "{{ data_dir }}/postgres"
        state: absent
      when: force_postgres_reinit | default(false) | bool

    - name: Recreate PostgreSQL data directory
      file:
        path: "{{ data_dir }}/postgres"
        state: directory
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: '0755'
      when: force_postgres_reinit | default(false) | bool

    # =========================================================================
    # Docker Registry & Pull
    # =========================================================================
    - name: Login to GitHub Container Registry
      community.docker.docker_login:
        registry: ghcr.io
        username: "{{ ghcr_username }}"
        password: "{{ ghcr_token }}"
      when: ghcr_token is defined and ghcr_token | length > 0

    - name: Pull latest images (excluding locally built images)
      shell: cd {{ app_dir }} && docker compose -f {{ compose_file }} pull --ignore-buildable
      ignore_errors: yes

    - name: Build custom Caddy image with Hetzner DNS plugin
      shell: cd {{ app_dir }} && docker compose -f {{ compose_file }} build caddy
      register: caddy_build

    # =========================================================================
    # Start Infrastructure Containers (Database, Cache, Search)
    # =========================================================================
    - name: Start infrastructure containers only (postgres, redis, meilisearch)
      shell: |
        cd {{ app_dir }}
        docker compose -f {{ compose_file }} up -d postgres redis meilisearch
      register: infra_start

    - name: Wait for PostgreSQL to be healthy
      shell: |
        for i in {1..60}; do
          docker exec mandari-postgres pg_isready -U ${POSTGRES_USER:-mandari} && exit 0
          sleep 2
        done
        exit 1
      environment:
        POSTGRES_USER: "{{ lookup('env', 'POSTGRES_USER') | default('mandari', true) }}"
      register: pg_ready
      retries: 3
      delay: 5
      until: pg_ready.rc == 0

    - name: Wait for PostgreSQL to fully initialize
      pause:
        seconds: 5

    # =========================================================================
    # Run Migrations BEFORE starting API (prevents race condition)
    # =========================================================================
    - name: Get Docker network name
      shell: docker network ls --filter name=mandari --format '{{ '{{' }}.Name{{ '}}' }}' | grep -E 'mandari.*network' | head -1
      register: docker_network
      changed_when: false

    - name: Run database migrations using temporary container
      shell: |
        cd {{ app_dir }}
        # Load environment variables from .env file (POSIX compatible)
        export $(grep -v '^#' .env | xargs)
        # Get the network name
        NETWORK_NAME="{{ docker_network.stdout | default('mandari_mandari-network') }}"

        # Helper function to run Django commands
        run_django() {
          docker run --rm \
            --network "$NETWORK_NAME" \
            --env-file .env \
            -e DATABASE_URL="postgresql://${POSTGRES_USER:-mandari}:${POSTGRES_PASSWORD}@mandari-postgres:5432/${POSTGRES_DB:-mandari}" \
            -e ALLOWED_HOSTS="localhost" \
            ghcr.io/mandarioss/mandari:${IMAGE_TAG:-latest} \
            "$@"
        }

        # Try normal migration first
        echo "Running migrations..."
        if run_django python manage.py migrate --noinput 2>&1 | tee /tmp/migrate.log; then
          echo "✅ Migrations completed successfully"
          exit 0
        fi

        # Check if failure was due to DuplicateColumn (schema created by ingestor)
        if grep -q "DuplicateColumn\|already exists" /tmp/migrate.log; then
          echo "⚠️ Schema conflict detected (columns exist from ingestor), faking insight_core migrations..."
          run_django python manage.py migrate insight_core --fake --noinput
          # Retry full migration
          run_django python manage.py migrate --noinput
          exit $?
        fi

        # For other failures, just fail
        echo "❌ Migration failed"
        cat /tmp/migrate.log
        exit 1
      args:
        executable: /bin/bash
      register: migration_result
      retries: 2
      delay: 10
      until: migration_result.rc == 0

    - name: Display migration result
      debug:
        msg: "{{ migration_result.stdout_lines | default(['Migrations completed']) }}"

    - name: Setup Django roles and permissions
      shell: |
        cd {{ app_dir }}
        export $(grep -v '^#' .env | xargs)
        NETWORK_NAME="{{ docker_network.stdout | default('mandari_mandari-network') }}"
        docker run --rm \
          --network "$NETWORK_NAME" \
          --env-file .env \
          -e DATABASE_URL="postgresql://${POSTGRES_USER:-mandari}:${POSTGRES_PASSWORD}@mandari-postgres:5432/${POSTGRES_DB:-mandari}" \
          -e ALLOWED_HOSTS="localhost" \
          ghcr.io/mandarioss/mandari:${IMAGE_TAG:-latest} \
          python manage.py setup_roles
      args:
        executable: /bin/bash
      register: setup_roles_result

    - name: Display setup_roles result
      debug:
        msg: "{{ setup_roles_result.stdout_lines | default(['Roles setup completed']) }}"

    # =========================================================================
    # Initialize OParl Sources (ensures ingestor has data to sync)
    # =========================================================================
    - name: Initialize OParl sources (default German municipalities)
      shell: |
        cd {{ app_dir }}
        export $(grep -v '^#' .env | xargs)
        NETWORK_NAME="{{ docker_network.stdout | default('mandari_mandari-network') }}"
        docker run --rm \
          --network "$NETWORK_NAME" \
          --env-file .env \
          -e DATABASE_URL="postgresql://${POSTGRES_USER:-mandari}:${POSTGRES_PASSWORD}@mandari-postgres:5432/${POSTGRES_DB:-mandari}" \
          -e REDIS_URL="redis://mandari-redis:6379" \
          -e MEILISEARCH_URL="http://mandari-meilisearch:7700" \
          ghcr.io/mandarioss/ingestor:${IMAGE_TAG:-latest} \
          python -m src.main init-sources --default
      args:
        executable: /bin/bash
      register: init_sources_result
      ignore_errors: yes

    - name: Display init-sources result
      debug:
        msg: "{{ init_sources_result.stdout_lines | default(['OParl sources initialized']) }}"
      when: init_sources_result is defined

    # =========================================================================
    # Now Start All Containers (API, Ingestor, Caddy)
    # =========================================================================
    - name: Start all containers
      community.docker.docker_compose_v2:
        project_src: "{{ app_dir }}"
        files:
          - "{{ compose_file }}"
        state: present
        recreate: always
        remove_orphans: true
      register: compose_result

    # =========================================================================
    # Health Check
    # =========================================================================
    - name: Wait for API to be healthy
      shell: docker inspect --format='{{ '{{' }}.State.Health.Status{{ '}}' }}' mandari-web
      register: api_health
      retries: 30
      delay: 5
      until: api_health.stdout == 'healthy'

    # =========================================================================
    # Wait for SSL Certificate and Export for Slave
    # =========================================================================
    - name: Wait for Caddy to obtain SSL certificate
      shell: >-
        for i in $(seq 1 60); do
        if docker exec mandari-caddy ls /data/caddy/certificates/acme-v02.api.letsencrypt.org-directory/mandari.de/mandari.de.crt 2>/dev/null; then
        echo "Certificate found"; exit 0; fi;
        echo "Waiting for certificate... attempt $i"; sleep 10; done;
        echo "Certificate not found after 10 minutes"; exit 1
      args:
        executable: /bin/bash
      register: cert_wait
      retries: 2
      delay: 30
      until: cert_wait.rc == 0

    - name: Create temporary directory for certificate export
      file:
        path: /tmp/caddy-certs
        state: directory
        mode: '0700'

    - name: Export Caddy certificate data from Docker volume
      shell: >-
        docker run --rm
        -v mandari_caddy_data:/data:ro
        -v /tmp/caddy-certs:/backup
        alpine:latest
        sh -c "cp -r /data/caddy /backup/ 2>/dev/null || true"
      register: cert_export

    - name: Verify certificate export
      stat:
        path: /tmp/caddy-certs/caddy
      register: cert_exported

    - name: Fail if certificate export failed
      fail:
        msg: "Failed to export Caddy certificates from Master"
      when: not cert_exported.stat.exists

    - name: Master deployment complete
      debug:
        msg: "✅ Master deployment complete. Migrations applied. SSL certificate exported."

# =============================================================================
# PHASE 1.5: Transfer SSL Certificates from Master to Slave
# =============================================================================
- name: Transfer SSL Certificates
  hosts: master
  become: yes
  gather_facts: no

  tasks:
    - name: Archive certificate data on Master
      archive:
        path: /tmp/caddy-certs/caddy
        dest: /tmp/caddy-certs.tar.gz
        format: gz

    - name: Fetch certificate archive from Master to Ansible controller
      fetch:
        src: /tmp/caddy-certs.tar.gz
        dest: /tmp/caddy-certs-transfer/
        flat: yes

    - name: Clean up temporary files on Master
      file:
        path: "{{ item }}"
        state: absent
      loop:
        - /tmp/caddy-certs
        - /tmp/caddy-certs.tar.gz

- name: Copy SSL Certificates to Slave
  hosts: slave
  become: yes
  gather_facts: no

  tasks:
    - name: Create certificate directory on Slave
      file:
        path: /tmp/caddy-certs
        state: directory
        mode: '0700'

    - name: Copy certificate archive to Slave
      copy:
        src: /tmp/caddy-certs-transfer/caddy-certs.tar.gz
        dest: /tmp/caddy-certs.tar.gz
        mode: '0600'

    - name: Extract certificate archive on Slave
      unarchive:
        src: /tmp/caddy-certs.tar.gz
        dest: /tmp/caddy-certs/
        remote_src: yes

    - name: Verify certificate extracted on Slave
      stat:
        path: /tmp/caddy-certs/caddy
      register: slave_cert_check

    - name: Certificates transferred
      debug:
        msg: "✅ SSL certificates transferred to Slave"
      when: slave_cert_check.stat.exists

    - name: Clean up archive on Slave
      file:
        path: /tmp/caddy-certs.tar.gz
        state: absent

# =============================================================================
# PHASE 2: Deploy Slave (Replica) - AFTER Master is ready
# =============================================================================
- name: Deploy Slave Server
  hosts: slave
  become: yes
  gather_facts: yes
  serial: 1

  vars:
    compose_file: "docker-compose.slave.yml"
    deploy_timestamp: "{{ ansible_facts['date_time']['epoch'] }}"

  tasks:
    # =========================================================================
    # Verify Master Database is Reachable BEFORE any deployment
    # =========================================================================
    - name: Wait for Master PostgreSQL to be reachable
      wait_for:
        host: "{{ master_private_ip | default('10.0.0.3') }}"
        port: 5432
        state: started
        timeout: 120
      register: master_db_check

    - name: Verify PostgreSQL connection to Master
      shell: |
        apt-get install -y postgresql-client 2>/dev/null || true
        PGPASSWORD="{{ lookup('env', 'POSTGRES_PASSWORD') }}" psql -h {{ master_private_ip | default('10.0.0.3') }} -U {{ lookup('env', 'POSTGRES_USER') | default('mandari', true) }} -d {{ lookup('env', 'POSTGRES_DB') | default('mandari', true) }} -c "SELECT 1" >/dev/null 2>&1
      register: pg_connection_test
      retries: 5
      delay: 5
      until: pg_connection_test.rc == 0
      ignore_errors: yes

    - name: Display Master DB connection status
      debug:
        msg: "{{ 'Master PostgreSQL is reachable' if pg_connection_test.rc == 0 else 'Warning: Could not verify PostgreSQL connection, proceeding anyway' }}"

    # =========================================================================
    # Cleanup & Prepare (WITHOUT removing volumes - we need caddy_data!)
    # =========================================================================
    - name: Stop all existing containers (preserve volumes for SSL cert)
      shell: |
        cd {{ app_dir }} && docker compose down --remove-orphans 2>/dev/null || true
        docker ps -a --filter "name=mandari-" -q | xargs -r docker rm -f 2>/dev/null || true
      ignore_errors: yes

    - name: Sync Docker Compose files
      copy:
        src: "{{ playbook_dir }}/../../docker/{{ item }}"
        dest: "{{ app_dir }}/{{ item }}"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: '0644'
      loop:
        - docker-compose.master.yml
        - docker-compose.slave.yml
        - Caddyfile
        - pg_hba.conf

    - name: Sync Caddy Dockerfile directory
      copy:
        src: "{{ playbook_dir }}/../../docker/caddy/"
        dest: "{{ app_dir }}/caddy/"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: '0644'

    - name: Sync environment file
      copy:
        src: "{{ playbook_dir }}/../../docker/.env"
        dest: "{{ app_dir }}/.env"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: '0600'

    - name: Create Docker Compose symlink
      file:
        src: "{{ app_dir }}/{{ compose_file }}"
        dest: "{{ app_dir }}/docker-compose.yml"
        state: link
        force: yes

    # =========================================================================
    # PostgreSQL Replica Initialization
    # =========================================================================
    - name: Create PostgreSQL and Redis data directories
      file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
      loop:
        - "{{ data_dir }}/postgres"
        - "{{ data_dir }}/redis"

    - name: Check if PostgreSQL replica is already initialized
      stat:
        path: "{{ data_dir }}/postgres/standby.signal"
      register: standby_signal

    - name: Check if PostgreSQL data directory has data
      find:
        paths: "{{ data_dir }}/postgres"
        patterns: "PG_VERSION"
      register: pg_version_file

    - name: Initialize PostgreSQL replica via pg_basebackup
      shell: |
        # Stop any existing postgres container
        docker stop mandari-postgres 2>/dev/null || true
        docker rm mandari-postgres 2>/dev/null || true

        # Clear data directory if it exists but is incomplete
        rm -rf {{ data_dir }}/postgres/* 2>/dev/null || true

        # Run pg_basebackup from master
        docker run --rm \
          --network host \
          -v {{ data_dir }}/postgres:/var/lib/postgresql/data \
          -e PGPASSWORD="{{ lookup('env', 'POSTGRES_PASSWORD') }}" \
          postgres:16-alpine \
          pg_basebackup \
            -h {{ master_private_ip | default('10.0.0.3') }} \
            -p 5432 \
            -U {{ lookup('env', 'POSTGRES_USER') | default('mandari', true) }} \
            -D /var/lib/postgresql/data \
            -Fp \
            -Xs \
            -P \
            -R

        # Create standby.signal (PostgreSQL 12+ requirement)
        touch {{ data_dir }}/postgres/standby.signal

        # Set permissions for postgres user in container (uid 999)
        chown -R 999:999 {{ data_dir }}/postgres
      args:
        executable: /bin/bash
      when: not standby_signal.stat.exists or pg_version_file.matched == 0
      register: replica_init
      retries: 2
      delay: 10
      until: replica_init.rc == 0

    - name: Display replica initialization result
      debug:
        msg: "{{ 'PostgreSQL replica initialized successfully' if replica_init.changed else 'PostgreSQL replica already initialized' }}"

    # =========================================================================
    # Docker Registry & Pull
    # =========================================================================
    - name: Login to GitHub Container Registry
      community.docker.docker_login:
        registry: ghcr.io
        username: "{{ ghcr_username }}"
        password: "{{ ghcr_token }}"
      when: ghcr_token is defined and ghcr_token | length > 0

    - name: Pull latest images (excluding locally built images)
      shell: cd {{ app_dir }} && docker compose -f {{ compose_file }} pull --ignore-buildable
      ignore_errors: yes

    - name: Build custom Caddy image with Hetzner DNS plugin
      shell: cd {{ app_dir }} && docker compose -f {{ compose_file }} build caddy
      register: caddy_build

    # =========================================================================
    # Import SSL Certificates from Master (only if transferred)
    # =========================================================================
    - name: Check if certificate data exists
      stat:
        path: /tmp/caddy-certs/caddy
      register: slave_certs

    - name: Create Caddy data volume if not exists
      shell: docker volume create mandari_caddy_data
      ignore_errors: yes
      when: slave_certs.stat.exists

    - name: Import SSL certificates into Caddy volume
      shell: >-
        docker run --rm
        -v mandari_caddy_data:/data
        -v /tmp/caddy-certs:/backup:ro
        alpine:latest
        sh -c "mkdir -p /data && cp -r /backup/caddy /data/ 2>/dev/null || true"
      when: slave_certs.stat.exists
      register: cert_import

    - name: Verify certificate import
      shell: >-
        docker run --rm
        -v mandari_caddy_data:/data:ro
        alpine:latest
        ls -la /data/caddy/certificates/acme-v02.api.letsencrypt.org-directory/mandari.de/ 2>/dev/null || echo "No certificates yet"
      register: cert_verify
      when: slave_certs.stat.exists

    - name: Display certificate import status
      debug:
        msg: "Certificate import result: {{ cert_verify.stdout_lines | default(['No output']) }}"
      when: slave_certs.stat.exists

    - name: Clean up temporary certificate directory on Slave
      file:
        path: /tmp/caddy-certs
        state: absent

    # =========================================================================
    # Start Containers
    # =========================================================================
    - name: Start all containers
      community.docker.docker_compose_v2:
        project_src: "{{ app_dir }}"
        files:
          - "{{ compose_file }}"
        state: present
        recreate: always
        remove_orphans: true

    # =========================================================================
    # Health Check
    # =========================================================================
    - name: Wait for API to be healthy
      shell: docker inspect --format='{{ '{{' }}.State.Health.Status{{ '}}' }}' mandari-web
      register: api_health
      retries: 30
      delay: 5
      until: api_health.stdout == 'healthy'
      ignore_errors: yes

    # =========================================================================
    # Verify Replication Status
    # =========================================================================
    - name: Wait for PostgreSQL replica to be healthy
      shell: docker inspect --format='{{ '{{' }}.State.Health.Status{{ '}}' }}' mandari-postgres
      register: pg_health
      retries: 30
      delay: 5
      until: pg_health.stdout == 'healthy'
      ignore_errors: yes

    - name: Verify PostgreSQL is in recovery mode (replica)
      shell: docker exec mandari-postgres psql -U {{ lookup('env', 'POSTGRES_USER') | default('mandari', true) }} -tAc "SELECT pg_is_in_recovery();"
      register: recovery_mode
      retries: 5
      delay: 5
      until: recovery_mode.stdout | trim == 't'
      ignore_errors: yes

    - name: Display replication status
      debug:
        msg: "PostgreSQL replica status: {{ 'REPLICATING' if recovery_mode.stdout | trim == 't' else 'NOT REPLICATING - CHECK LOGS!' }}"

    # =========================================================================
    # Certificate Sync Setup (Slave only)
    # =========================================================================
    - name: Copy certificate sync script
      copy:
        src: "{{ playbook_dir }}/../../scripts/sync-certs.sh"
        dest: "{{ app_dir }}/scripts/sync-certs.sh"
        owner: root
        group: root
        mode: '0755'

    - name: Setup daily certificate sync cron job
      cron:
        name: "Sync SSL certificates from Master"
        minute: "0"
        hour: "3"
        job: "MASTER_PRIVATE_IP={{ master_private_ip | default('10.0.0.3') }} {{ app_dir }}/scripts/sync-certs.sh >> /var/log/cert-sync.log 2>&1"
        state: present

    - name: Slave deployment complete
      debug:
        msg: |
          ✅ Slave deployment complete (HIGH AVAILABILITY)
          Services: API, Caddy, Meilisearch, PostgreSQL (replica), Redis (replica)
          PostgreSQL: Hot Standby from Master ({{ master_private_ip | default('10.0.0.3') }})
          Redis: Replica from Master ({{ master_private_ip | default('10.0.0.3') }})
          Replication: {{ 'ACTIVE' if recovery_mode.stdout | trim == 't' else 'CHECK REQUIRED' }}
          Certificate Sync: Daily at 3:00 AM

# =============================================================================
# PHASE 3: Final Verification
# =============================================================================
- name: Verify Deployment
  hosts: all_servers
  become: yes
  gather_facts: no

  tasks:
    - name: Check running containers
      shell: docker ps --format "table {{'{{'}}.Names{{'}}'}}\\t{{'{{'}}.Status{{'}}'}}\\t{{'{{'}}.Ports{{'}}'}}"
      register: docker_ps

    - name: Display running containers
      debug:
        msg: "{{ docker_ps.stdout_lines }}"

    - name: Final health check
      uri:
        url: "http://localhost/health"
        method: GET
        status_code: 200
      register: health_check
      retries: 5
      delay: 5
      until: health_check.status == 200
      ignore_errors: yes

    - name: Check PostgreSQL replication status (master only)
      shell: docker exec mandari-postgres psql -U {{ lookup('env', 'POSTGRES_USER') | default('mandari', true) }} -tAc "SELECT count(*) FROM pg_stat_replication;"
      register: replication_count
      when: postgres_role == 'primary'
      ignore_errors: yes

    - name: Deployment summary
      debug:
        msg: |
          ==========================================
          Deployment Complete!
          ==========================================
          Server: {{ inventory_hostname }}
          Role: {{ postgres_role }}
          Health: {{ 'OK' if health_check.status == 200 else 'FAILED' }}
          {% if postgres_role == 'primary' %}
          Replicas connected: {{ replication_count.stdout | default('0') | trim }}
          {% endif %}
          ==========================================

# =============================================================================
# PHASE 4: Cleanup on Ansible Controller
# =============================================================================
- name: Cleanup Ansible Controller
  hosts: localhost
  connection: local
  gather_facts: no

  tasks:
    - name: Remove temporary certificate transfer directory
      file:
        path: /tmp/caddy-certs-transfer
        state: absent
      ignore_errors: yes

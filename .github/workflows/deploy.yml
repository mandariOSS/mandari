# =============================================================================
# Mandari 2.0 - CI/CD Pipeline
# =============================================================================
# Automatisches Deployment bei Push auf main/production Branch
#
# Workflow:
# 1. Build & Test
# 2. Build Docker Images
# 3. Push to Registry
# 4. Deploy to Servers via Ansible
# =============================================================================

name: Deploy Mandari

on:
  push:
    branches:
      - main
      - production
    paths-ignore:
      - '*.md'
      - 'docs/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip tests'
        required: false
        default: false
        type: boolean
      force_db_reinit:
        description: 'Force PostgreSQL reinitialization (DELETES ALL DATA!)'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  # Docker images: ghcr.io/mandarioss/mandari, ghcr.io/mandarioss/ingestor
  IMAGE_OWNER: mandarioss

jobs:
  # ===========================================================================
  # Test
  # ===========================================================================
  test:
    name: Test
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_tests }}

    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            libcairo2-dev \
            libpango1.0-dev \
            libffi-dev \
            shared-mime-info \
            pkg-config \
            poppler-utils \
            tesseract-ocr \
            tesseract-ocr-deu

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Install dependencies
        run: |
          cd mandari
          pip install -r requirements.txt
          pip install pytest pytest-django pytest-cov

      - name: Run tests
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/test
          REDIS_URL: redis://localhost:6379
          SECRET_KEY: test-secret-key-for-ci
          DEBUG: 'false'
        run: |
          cd mandari
          python manage.py migrate --noinput
          python manage.py collectstatic --noinput
          pytest --cov=. --cov-report=xml

      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          file: ./mandari/coverage.xml
          fail_ci_if_error: false

  # ===========================================================================
  # Build Docker Images
  # ===========================================================================
  build:
    name: Build Images
    runs-on: ubuntu-latest
    needs: [test]
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped')

    permissions:
      contents: read
      packages: write

    outputs:
      image_tag: ${{ steps.meta.outputs.version }}

    strategy:
      matrix:
        include:
          - context: ./mandari
            image: mandari       # ghcr.io/mandarioss/mandari
          - context: ./apps/ingestor
            image: ingestor      # ghcr.io/mandarioss/ingestor

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/${{ matrix.image }}
          tags: |
            type=sha,prefix=
            type=ref,event=branch
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production' }}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.context }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            GIT_SHA=${{ github.sha }}

  # ===========================================================================
  # Deploy to Production
  # ===========================================================================
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    needs: [build]
    # Only deploy if secrets are configured (infrastructure exists)
    if: |
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production' || github.event_name == 'workflow_dispatch')
      && vars.DEPLOYMENT_ENABLED == 'true'

    environment:
      name: ${{ inputs.environment || 'production' }}
      url: https://mandari.de

    concurrency:
      group: deploy-${{ inputs.environment || 'production' }}
      cancel-in-progress: false

    steps:
      - name: Check deployment prerequisites
        run: |
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ] || [ -z "${{ secrets.MASTER_IP }}" ]; then
            echo "‚ùå Deployment secrets not configured!"
            echo "Required secrets: SSH_PRIVATE_KEY, MASTER_IP, SLAVE_IP"
            echo "Set DEPLOYMENT_ENABLED=true in repository variables when ready."
            exit 1
          fi
          if [ -z "${{ secrets.GHCR_TOKEN }}" ]; then
            echo "‚ö†Ô∏è Warning: GHCR_TOKEN not set!"
            echo "If packages are private, you need a Personal Access Token with read:packages scope."
            echo "Create one at: https://github.com/settings/tokens/new?scopes=read:packages"
            echo "Then add it as GHCR_TOKEN secret in repository settings."
          fi

      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Ansible
        run: |
          pip install ansible ansible-lint
          ansible-galaxy install -r infrastructure/ansible/requirements.yml || true

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          if [ -n "${{ secrets.MASTER_IP }}" ]; then
            ssh-keyscan -H "${{ secrets.MASTER_IP }}" >> ~/.ssh/known_hosts 2>/dev/null || true
          fi
          if [ -n "${{ secrets.SLAVE_IP }}" ]; then
            ssh-keyscan -H "${{ secrets.SLAVE_IP }}" >> ~/.ssh/known_hosts 2>/dev/null || true
          fi

      - name: Create Ansible inventory
        run: |
          cat > infrastructure/ansible/inventory/production.yml << EOF
          all:
            vars:
              ansible_user: root
              ansible_python_interpreter: /usr/bin/python3
              ansible_ssh_common_args: '-o StrictHostKeyChecking=no'
              app_name: mandari
              app_user: deploy
              app_dir: /opt/mandari
              data_dir: /mnt/data
              image_tag: ${{ needs.build.outputs.image_tag || github.sha }}
              docker_registry: ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}

              # Network settings (Hetzner private network: 10.0.0.0/16)
              private_network_cidr: "10.0.0.0/16"
              master_private_ip: "10.0.0.3"
              slave_private_ip: "10.0.0.4"

              # PostgreSQL settings
              postgres_version: "16"
              postgres_max_connections: "200"
              postgres_shared_buffers: "2GB"
              postgres_effective_cache_size: "6GB"

            children:
              master:
                hosts:
                  mandari-master:
                    ansible_host: ${{ secrets.MASTER_IP }}
                    private_ip: "10.0.0.3"
                    postgres_role: primary
                    redis_role: master
                    run_ingestor: true

              slave:
                hosts:
                  mandari-slave:
                    ansible_host: ${{ secrets.SLAVE_IP }}
                    private_ip: "10.0.0.4"
                    postgres_role: replica
                    redis_role: replica
                    run_ingestor: false

              all_servers:
                children:
                  master:
                  slave:
          EOF

      - name: Create environment file
        run: |
          cat > infrastructure/docker/.env << EOF
          # Domain & URLs
          DOMAIN=mandari.de
          SITE_URL=${{ secrets.SITE_URL }}
          ALLOWED_HOSTS=${{ secrets.ALLOWED_HOSTS }}
          CSRF_TRUSTED_ORIGINS=${{ secrets.CSRF_TRUSTED_ORIGINS }}

          # Security
          SECRET_KEY=${{ secrets.SECRET_KEY }}
          ENCRYPTION_MASTER_KEY=${{ secrets.ENCRYPTION_MASTER_KEY }}

          # Database
          POSTGRES_USER=${{ secrets.POSTGRES_USER || 'mandari' }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB=${{ secrets.POSTGRES_DB || 'mandari' }}
          REPLICATION_PASSWORD=${{ secrets.REPLICATION_PASSWORD || secrets.POSTGRES_PASSWORD }}

          # Services
          MEILISEARCH_KEY=${{ secrets.MEILISEARCH_KEY }}
          REDIS_MAXMEMORY=512mb

          # Hetzner DNS (for Let's Encrypt DNS-01 challenge)
          HETZNER_DNS_API_TOKEN=${{ secrets.HETZNER_DNS_API_TOKEN }}

          # Network (Hetzner private network: 10.0.0.0/16)
          MASTER_PRIVATE_IP=10.0.0.3

          # Directories & Images
          DATA_DIR=/mnt/data
          IMAGE_TAG=${{ needs.build.outputs.image_tag || github.sha }}
          EOF

      - name: Deploy with Ansible
        working-directory: infrastructure/ansible
        env:
          ANSIBLE_HOST_KEY_CHECKING: 'false'
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          # Database credentials for Ansible lookup('env', ...) functions
          POSTGRES_USER: ${{ secrets.POSTGRES_USER || 'mandari' }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB || 'mandari' }}
        run: |
          # Build extra-vars for Ansible
          EXTRA_VARS=""
          if [ -n "$GHCR_TOKEN" ]; then
            EXTRA_VARS="ghcr_username=${{ github.repository_owner }} ghcr_token=${GHCR_TOKEN}"
          fi
          # Add force_postgres_reinit if requested
          if [ "${{ inputs.force_db_reinit }}" = "true" ]; then
            EXTRA_VARS="$EXTRA_VARS force_postgres_reinit=true"
          fi
          ansible-playbook -i inventory/production.yml playbooks/deploy.yml \
            ${EXTRA_VARS:+--extra-vars "$EXTRA_VARS"}

      - name: Health check
        env:
          MASTER_IP: ${{ secrets.MASTER_IP }}
          SLAVE_IP: ${{ secrets.SLAVE_IP }}
        run: |
          echo "Waiting for deployment to stabilize..."
          sleep 30

          # Try multiple health check methods
          check_health() {
            # Method 1: Direct server check via HTTP (most reliable)
            if curl -sf --connect-timeout 5 "http://${MASTER_IP}/health" > /dev/null 2>&1; then
              echo "‚úÖ Master server health check passed (direct HTTP)"
              return 0
            fi

            # Method 2: HTTPS via domain (if SSL cert is ready)
            if curl -sf --connect-timeout 5 -k "https://mandari.de/health" > /dev/null 2>&1; then
              echo "‚úÖ Health check passed (HTTPS)"
              return 0
            fi

            # Method 3: HTTP via domain (LB might redirect)
            if curl -sf --connect-timeout 5 "http://mandari.de/health" > /dev/null 2>&1; then
              echo "‚úÖ Health check passed (HTTP)"
              return 0
            fi

            return 1
          }

          # Retry loop
          for i in {1..10}; do
            if check_health; then
              exit 0
            fi
            echo "Attempt $i failed, retrying..."
            sleep 10
          done

          # Final diagnostic info
          echo "‚ùå Health check failed!"
          echo "Debug info:"
          echo "Master IP: ${MASTER_IP}"
          curl -v --connect-timeout 5 "http://${MASTER_IP}/health" 2>&1 | head -20 || true
          exit 1

      - name: Notify on failure
        if: failure()
        run: |
          echo "‚ùå Deployment failed!"
          echo "Check the workflow run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          # Don't fail the job just because notification failed

  # ===========================================================================
  # Post-Deploy Tasks
  # ===========================================================================
  post-deploy:
    name: Post-Deploy
    runs-on: ubuntu-latest
    needs: [deploy]
    if: success()

    steps:
      - name: Notify success
        run: |
          echo "üöÄ Deployment successful!"
          echo "Version: ${{ github.sha }}"
          echo "URL: https://mandari.de"
          echo "Environment: ${{ inputs.environment || 'production' }}"
